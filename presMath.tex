
\documentclass[11pt,a4paper]{beamer}

\usetheme{metropolis}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{hyperref}

\theoremstyle{plain}
\newtheorem{thm}{Théorème}[section]
\newtheorem{lem}[thm]{Lemme}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollaire}

\theoremstyle{definition}
\newtheorem{defn}{Définition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Exemple}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remarque}
\newtheorem*{notation}{Notation}

\title{Coq, théorie de la démonstration et CompCert}
\author{Pierre Gimalac, Maxime Flin, Alexandre Moine}

\begin{document}
\maketitle

\begin{frame}{Sommaire}
\tableofcontents
\end{frame}

\section{Compcert}

\begin{frame}{Introduction}
Les compilateurs sont des logiciels critiques:
\begin{itemize}
	\item Ils peuvent introduire des bugs...
	\item Très difficile à trouver et à corriger.
	\item Et on ne peut pas se passer de leur utilisation!
\end{itemize}
L'idée (un peu folle) est donc d'essayer de les \emph{certifier} mathématiquement
\end{frame}

\begin{frame}{COQ à la rescousse}
Plus généralement, il est bon d'avoir des logiciels prouvés mathématiquement, et pour cela, des assistants de preuves existent. Par exemple COQ, que l'on peut utiliser comme:
\begin{itemize}
\item Comme langage de programmation
\item Comme langage de vérification
\item Comme langage exportable vers OCaml
\end{itemize}
Mais comment ça marche ? Sur quelles bases mathématiques ?
\end{frame}

\section{Logique du premier ordre et d'ordre supérieur}
\begin{frame}
\frametitle{Logique d'ordre supérieur}
Logique du premier ordre permet de quantifier seulement des objets du premier ordres (variables, constantes) mais pas des objets comme des ensembles, des groupes,etc... qui sont d'ordre supérieur.
\newline
\newline
``Toute partie non vide de $\mathbb{N}$ admet un plus petit élément``:
\[ \forall X \left(\neg =(X, \emptyset)\rightarrow\exists p~(X(p)\wedge\forall n~(X(x)\rightarrow \leq(p, n)))\right)\]
\end{frame}

\begin{frame}
\frametitle{Sortes}
\begin{defn}
On choisit $\mathcal{S}_0$ qu'on appellera \textit{ensemble de sortes de base} et qui ne contient pas la sorte particulière $o$. On définit l'ensemble $\mathcal{S}$ des sortes par la grammaire:

\[ \mathcal{S} = o~|~\mathcal{S}_0~|~\mathcal{S}\rightarrow\mathcal{S} \]
\end{defn}

\begin{rem}
\begin{itemize}
\item La sorte $o$ est la sorte des formules
\item On note $\omega$ la sorte des entiers. La sorte $\omega \rightarrow \omega$ désigne la sorte des fonctions de $\mathbb{Z}$ dans lui même.
\item Contrairement à la logique du premier ordre les termes et les termes sont tout deux des formules mais pas de la même sorte.
\end{itemize}
\end{rem}
\end{frame}

\begin{frame}
\frametitle{Un langage d'ordre supérieur}
\begin{defn}
Un \textit{langage d'ordre supérieur} est défini pour un ensemble de sortes $\mathcal{S}$ et est l'ensemble des couples $(c,s)$ où $c$ est un symbole de constante et $s$ une sorte.
\end{defn}

\begin{exmp}
Un langage d'ordre supérieur pour décrire l'arithmétique contiendrait le couple
\[ \left(+, \omega \rightarrow \omega \rightarrow \omega\right) \]
\end{exmp}
\end{frame}

\begin{frame}
\frametitle{Logique d'ordre supérieur}
\begin{defn}
Une \textit{Logique d'ordre supérieur} est un triplet $(\mathcal{S}_0, \mathcal{L}, \mathcal{G})$ où
\begin{itemize}
\item $\mathcal{S}_0$ est l'ensemble des sortes de base
\item $\mathcal{L}$ est le langage d'ordre supérieur sur un ensemble de sortes $\mathcal{S}$ associé
\item $\mathcal{G}$ est un sous ensemble de $\mathcal{S}$. Il détermine l'ensemble des sortes que l'on peut quantifier
\end{itemize}
\end{defn}
\end{frame}

\begin{frame}
\frametitle{$\beta$-équivalence}
\begin{defn}[$\beta$-réduction]
On dit que $e$ se \textbf{$\beta$-réduit} à $e'$ si $e'$ est obtenue à partir de $e$ en remplaçant une sous expression $(x\rightarrow t)(u)$ par l'expression $t[x:=u]$.
\end{defn}

\begin{defn}[$\beta$-équivalence]
Deux expressions sont \textbf{$\beta$-équivalentes} si elles se $\beta$-réduisent, en une ou plusieurs étapes, à la même expression.
\end{defn}

\begin{thm}
Toute expression est égale à une unique expression ne contenant pas de sous expressions de la forme $(x\rightarrow t)(u)$
\end{thm}
\end{frame}

\section{Lambda calcul}
\begin{frame}
\frametitle{Lambda calcul}
\begin{defn}
On construit l'ensemble des $\lambda$-termes $\Lambda$ tel que
\begin{itemize}
\item Pour toute variable $x$, $x\in\Lambda$
\item Pour toute variable $x$ et $M\in\Lambda$, $(\lambda x.M)\in\Lambda$
\item Pour tout $M,N\in\Lambda$, $(M~N)\in\Lambda$
\end{itemize}
\end{defn}

\begin{notation}
\begin{itemize}
\item $M~N$ désigne $(M~N)$
\item $M~N~P$ désigne $((M~N)~P)$
\item $\lambda x.M~N$ désigne $\lambda x.(M~N)$
\item $\lambda xyz.M$ désigne $\lambda x.\lambda y. \lambda z. M$
\end{itemize}
\end{notation}
\end{frame}

\begin{frame}
\frametitle{$\alpha$-conversion, $\beta$-réduction}
\begin{defn}[$\alpha$-conversion]
Une $\alpha$-conversion est un changement de nom pour une abstraction. On change le nom de la variable partout où elle est correspond à cette abstraction et pour un nom de variable qui n'est pas abstrait.
\end{defn}

\begin{defn}[$\beta$-réduction]
La $\beta$-réduction traduit l'idée d'appliquer la fonction décrite par une abstraction. Ainsi, $(\lambda x.E)~E'\rightarrow_\beta E[x:=E']$ 
\end{defn}

\begin{defn}[$\beta$-équivalence]
On dit que deux $\lambda$-termes sont équivalents quand ils se $\beta$-réduisent au même $\lambda$-terme.
\end{defn}
\end{frame}

\begin{frame}{$\lambda$-calcul simplement typé - Le problème}
Le $\lambda$-calcul tel qu'il a été défini pose un problème, des $\lambda$-termes comme:
$$ \Omega = (\lambda x \ . \ xx) (\lambda x \ . \ xx) $$
ne $\beta$-réduisent pas. On a donc envie d'introduire une notion de \emph{type}, comme on définit un ensemble de départ pour une fonction.
\\
(Note: Il est évident que le $\lambda$-calcul simplement typé est moins expressif que le $\lambda$-calcul simple)
\end{frame}

\begin{frame}{$\lambda$-calcul simplement typé - La solution (à la Curry)}
\begin{defn}[Environnement]
Un environnement $\Gamma$ est une suite de variables associées à un type: $$\Gamma = x_0:\sigma_0;...;x_n:\sigma_n$$
\end{defn}
\begin{defn}[jugement]
Un jugement d'un lambda terme $M$ est l'affirmation de son type dans un environnement $\Gamma$:
$$ \Gamma \vdash M : \sigma $$
\end{defn}
\end{frame}

\begin{frame}{Les règles de typage}
\begin{itemize}
	\item  $ \Gamma = x:\sigma, \quad \Gamma \vdash x : \sigma $
	\item  $ \Gamma = x:\sigma;M:\tau, \quad \Gamma \vdash \lambda x.M : \sigma \to \tau $
	\item  $ \Gamma = M:\sigma \to \tau; N: \sigma, \quad \Gamma \vdash MN : \tau $
\end{itemize}
On voit que ce système permet de préserver une cohérence des $\lambda$-termes dans un certains environnement
\end{frame}

\begin{frame}{Quelques résultats}
\begin{prop}
La $\beta$-réduction préserve les types
\end{prop}

\begin{prop}[Normalisation forte]
Toute $\beta$-réduction d'un $\lambda$-terme correctement typé termine
\end{prop}
\end{frame}

\section{Théorie de la démonstration}
\begin{frame}
\frametitle{La notion de séquent}
\begin{defn}
Un \textbf{séquent} est un couple noté $\Gamma \vdash F$ où
\begin{itemize}
	\item $\Gamma$ est un ensemble fini de formules. On l'appelle contexte
	\item $F$ est une formule. On l'appelle conclusion
\end{itemize}
\end{defn}

\begin{rem}
Les formules de $\Gamma$ et $F$ ne sont pas nécessairement closes.
\end{rem}
\end{frame}

\begin{frame}
\frametitle{La notion de séquent}
\begin{defn}
Un séquent $\Gamma \vdash F$ est \textbf{démontrable} s'il existe une démonstration ayant ses hypothèses dans $\Gamma$ et $F$ pour conclusion.
\end{defn}

\begin{rem}
\begin{itemize}
	\item Quand on écrit $\Gamma \vdash F$ on considère que ce séquent est démontrable.
	\item Quand un séquent n'est pas prouvable, on écrit $\Gamma \nvdash F$.
	\item Si $\vdash F$ on dit que $F$ est une tautologie.
	\item Si $\nvdash F$ on dit que $F$ est une antilogie.
\end{itemize}
\end{rem}
\end{frame}

\begin{frame}
\frametitle{Définition de démonstration formelle}
\begin{defn}
Une \textbf{démonstration} est un arbre ayant pour feuille des séquents.

Tous les arbres de ce type ne sont bien sûr pas de démonstrations. On les construit l'ensemble des démonstration formelles par induction comme suit.
\end{defn}
\end{frame}

\begin{frame}
\frametitle{Règles d'induction}
\begin{defn}[L'axiome]
pour toute théorie $\Gamma$ et formule $A$
\begin{prooftree}
\AxiomC{}
\RightLabel{ax}
\UnaryInfC{$\Gamma,A\vdash A$}
\end{prooftree}
\end{defn}

\begin{defn}[L'affaiblissement]
Pour toute théorie $\Gamma$ et formule $A$
\begin{prooftree}
\AxiomC{$\Gamma\vdash A$}
\RightLabel{aff}
\UnaryInfC{$\Gamma,B\vdash A$}
\end{prooftree}
\end{defn}
\end{frame}

\begin{frame}
Pour toute théorie $\Gamma$ et formules $A, B$
\frametitle{Règles d'induction}
\begin{defn}[Introduction de l'implication]
\begin{prooftree}
\AxiomC{$\Gamma, A\vdash B$}
\RightLabel{$\rightarrow_i$}
\UnaryInfC{$\Gamma\vdash A \rightarrow B$}
\end{prooftree}
\end{defn}

\begin{defn}[Introduction de la conjonction]
\begin{prooftree}
\AxiomC{$\Gamma\vdash A$}
\AxiomC{$\Gamma \vdash B$}
\RightLabel{$\wedge_i$}
\BinaryInfC{$\Gamma\vdash A \rightarrow B$}
\end{prooftree}
\end{defn}

\begin{defn}[Introduction de la disjonction]
\begin{prooftree}
\AxiomC{$\Gamma\vdash A$}
\RightLabel{$\vee_i$}
\UnaryInfC{$\Gamma\vdash A \vee B$}
\end{prooftree}
\end{defn}
\end{frame}

\begin{frame}
\frametitle{Règles d'induction}
\begin{defn}[Élimination de l'implication]
\begin{prooftree}
\AxiomC{$\Gamma\vdash A \rightarrow B$}
\AxiomC{$\Gamma\vdash A$}
\RightLabel{$\rightarrow_e$}
\BinaryInfC{$\Gamma\vdash B$}
\end{prooftree}
\end{defn}

\begin{defn}[Élimination de la conjonction]
\begin{prooftree}
\AxiomC{$\Gamma\vdash A\wedge B$}
\RightLabel{$\wedge_e$}
\UnaryInfC{$\Gamma\vdash A$}
\end{prooftree}
\end{defn}

\begin{defn}[Élimination de la disjonction]
Pour toute théorie $\Gamma$ et formules $A, B, C$
\begin{prooftree}
\AxiomC{$\Gamma\vdash A\vee B$}
\AxiomC{$\Gamma, A \vdash C$}
\AxiomC{$\Gamma, B \vdash C$}
\RightLabel{$\vee_i$}
\TrinaryInfC{$\Gamma\vdash C$}
\end{prooftree}
\end{defn}
\end{frame}

\begin{frame}
\frametitle{Exemple de démonstration formelle}
On considère $\Gamma = \left\{\forall x~H(x)\rightarrow M(x), H(s)\right\}$
\begin{prooftree}
\AxiomC{}
\RightLabel{ax}
\UnaryInfC{$\Gamma\vdash \forall x~H(x)\rightarrow M(x)$}
\RightLabel{$\forall_e$}
\UnaryInfC{$\Gamma\vdash H(s)\rightarrow M(s)$}

\AxiomC{}
\RightLabel{ax}
\UnaryInfC{$\Gamma\vdash H(s)$}
\RightLabel{$\rightarrow_e$}
\BinaryInfC{$\Gamma\vdash M(s)$}
\end{prooftree}

C'est un syllogisme !

\end{frame}


\section{Transformation de Curry-Howard}

\begin{frame}
\frametitle{Une correspondance entre la logique et la programmation}
\begin{center}
\begin{tabular}{|c|c|}
\hline 
Logique & Programmation \\ 
\hline 
\hline
Hilbert & Logique combinatoire \\ 
\hline 
Déduction naturelle & $\lambda$-calcul \\ 
\hline 
hypothèse & variable libre \\ 
\hline 
élimination de l'implication & application \\ 
\hline 
introduction de l'implication & abstraction \\
\hline
\end{tabular} 
\end{center}
\end{frame}

\begin{frame}
\frametitle{Une correspondance entre la logique et la programmation}

\begin{prooftree}
\AxiomC{}
\RightLabel{ax}
\UnaryInfC{$\Gamma_1,\alpha\vdash\alpha$}
\end{prooftree}
$$  \Updownarrow $$
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma,x:\alpha\vdash x:\alpha$}
\end{prooftree}
\end{frame}

\begin{frame}
\frametitle{Une correspondance entre la logique et la programmation}

\begin{prooftree}
\AxiomC{$\Gamma,\alpha\vdash\beta$}
\RightLabel{$\rightarrow_i$}
\UnaryInfC{$\Gamma\vdash\alpha\rightarrow\beta$}
\end{prooftree}
$$  \Updownarrow $$
\begin{prooftree}
\AxiomC{$\Gamma,x:\alpha\vdash t:\beta$}
\UnaryInfC{$\Gamma\vdash \lambda .x:\alpha\rightarrow\beta$}
\end{prooftree}
\end{frame}

\begin{frame}
\frametitle{Une correspondance entre la logique et la programmation}

\begin{prooftree}
\AxiomC{$\Gamma\vdash\alpha\rightarrow\beta$}
\AxiomC{$\Gamma\vdash\alpha$}
\RightLabel{$\rightarrow_e$}
\BinaryInfC{$\Gamma\vdash\beta$}
\end{prooftree}
$$  \Updownarrow $$
\begin{prooftree}
\AxiomC{$\Gamma\vdash t:\alpha\rightarrow\beta$}
\AxiomC{$\Gamma\vdash x:\alpha$}
\BinaryInfC{$\Gamma\vdash t x:\beta$}
\end{prooftree}
\end{frame}

\section{Coq}

\begin{frame}{Introduction}
Coq est un \emph{assistant de preuve} développé par l'INRIA. Grâce à une sémantique précise (le langage \emph{Gallina}) il permet l'automatisation de la vérification de preuves mathématiques via l'isomorphisme de Curry-Howard.\\
Un de ses grands avantages est que Gallina est un langage fonctionnel, et donc qu'il permet aussi d'écrire des logiciels.
\end{frame}

\begin{frame}{Manque de Turing-complétude}
\emph{Gallina} est un langage fonctionnel typé:
\begin{itemize}
	\item Tout programme est donc fortement normalisé
	\item Donc tout programme termine
	\item Donc \emph{Gallina} n'est pas Turing-complet\footnote{Un langage Turing-complet est un langage ayant autant d'expressivité qu'une machine de Turing}
\end{itemize}

\end{frame}

\begin{frame}{Utilisations}
	\begin{itemize}
		\item La preuve du théorème des 4 couleurs (2005)
		\item La preuve du théorème de Feit et Thompson (2012)
		\item Compcert...
	\end{itemize}
\end{frame}

\section{Retour à Compcert}

\begin{frame}{bla}
	contenu...
\end{frame}

\section*{Sources}
\begin{frame}
\begin{itemize}
	\item \url{https://coq.inria.fr/}
	\item \url{http://compcert.inria.fr/}
	\item \url{http://perso.ens-lyon.fr/pierre.lescanne/ENSEIGNEMENT/PROG2/06-07/lambda_types.pdf}
\end{itemize}
\end{frame}
\end{document}